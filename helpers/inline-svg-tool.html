<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Image Inliner</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
    }
    .container {
      border: 2px solid #ccc;
      border-radius: 8px;
      padding: 20px;
      background: #f9f9f9;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin: 10px 5px;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .status {
      margin: 15px 0;
      padding: 10px;
      border-radius: 5px;
      display: none;
    }
    .status.success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .status.error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .status.info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    #preview {
      margin-top: 20px;
      border: 1px solid #ddd;
      padding: 10px;
      background: white;
      min-height: 200px;
    }
    textarea {
      width: 100%;
      height: 300px;
      font-family: monospace;
      font-size: 12px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>SVG Image Inliner</h1>
    <p>This tool converts external <code>&lt;image&gt;</code> tags in SVG files to inline embedded content.</p>

    <div>
      <label for="fileInput"><strong>Select SVG file:</strong></label><br>
      <input type="file" id="fileInput" accept=".svg" style="margin: 10px 0;">
    </div>

    <div style="margin: 15px 0;">
      <label for="folderInput"><strong>Or select folder with all SVG files:</strong></label><br>
      <input type="file" id="folderInput" webkitdirectory directory multiple style="margin: 10px 0;">
    </div>

    <div id="status" class="status"></div>

    <button id="processBtn" disabled>Process SVG</button>
    <button id="downloadBtn" disabled>Download Inlined SVG</button>
    <button id="toggleSource">Show/Hide Source</button>

    <div id="preview"></div>
    <textarea id="sourceCode" style="display: none;"></textarea>
  </div>

  <script>
    let processedSVG = null;
    let originalFileName = '';
    let folderFiles = new Map(); // Store files by their relative path

    const fileInput = document.getElementById('fileInput');
    const folderInput = document.getElementById('folderInput');
    const processBtn = document.getElementById('processBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const toggleSourceBtn = document.getElementById('toggleSource');
    const statusDiv = document.getElementById('status');
    const previewDiv = document.getElementById('preview');
    const sourceCode = document.getElementById('sourceCode');

    // Helper function to prompt user to select a file
    function selectFile(expectedPath) {
      return new Promise((resolve) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.svg';

        const message = `Please select the file: ${expectedPath}`;
        showStatus(message, 'info');

        input.onchange = (e) => {
          if (e.target.files.length > 0) {
            resolve(e.target.files[0]);
          } else {
            resolve(null);
          }
        };

        input.click();
      });
    }

    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        processBtn.disabled = false;
        originalFileName = e.target.files[0].name;
        showStatus('File selected: ' + originalFileName, 'info');
      }
    });

    folderInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        folderFiles.clear();

        // Build a map of all files by their relative path
        for (let file of e.target.files) {
          const path = file.webkitRelativePath;
          // Remove the root folder name to get relative path
          const relativePath = path.substring(path.indexOf('/') + 1);
          folderFiles.set(relativePath, file);
        }

        // Find the container SVG (assume it's in the root)
        const containerFile = Array.from(e.target.files).find(f => {
          const relativePath = f.webkitRelativePath.substring(f.webkitRelativePath.indexOf('/') + 1);
          return !relativePath.includes('/') && relativePath.endsWith('.svg');
        });

        if (containerFile) {
          fileInput.files = createFileList([containerFile]);
          originalFileName = containerFile.name;
          processBtn.disabled = false;
          showStatus(`Folder loaded: ${folderFiles.size} files found, using ${originalFileName}`, 'success');
        } else {
          showStatus('No SVG file found in root of selected folder', 'error');
        }
      }
    });

    // Helper to create a FileList (for compatibility)
    function createFileList(files) {
      const dt = new DataTransfer();
      files.forEach(file => dt.items.add(file));
      return dt.files;
    }

    processBtn.addEventListener('click', async () => {
      const file = fileInput.files[0];
      if (!file) return;

      showStatus('Processing...', 'info');
      processBtn.disabled = true;

      try {
        const svgText = await file.text();
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');

        // Check for parsing errors
        const parserError = svgDoc.querySelector('parsererror');
        if (parserError) {
          throw new Error('Invalid SVG file');
        }

        const svgElement = svgDoc.documentElement;
        const imageElements = svgDoc.querySelectorAll('image');

        if (imageElements.length === 0) {
          showStatus('No <image> elements found in SVG', 'error');
          processBtn.disabled = false;
          return;
        }

        showStatus(`Found ${imageElements.length} image(s). Please select each referenced file...`, 'info');

        // Get the base path from the original file
        const filePath = file.webkitRelativePath || file.name;
        const basePath = filePath.substring(0, filePath.lastIndexOf('/') + 1);

        // Process each image element
        for (let img of imageElements) {
          const href = img.getAttribute('href') || img.getAttributeNS('http://www.w3.org/1999/xlink', 'href');

          if (!href) continue;

          try {
            let externalFile;

            // First, try to find the file in the loaded folder
            if (folderFiles.size > 0) {
              externalFile = folderFiles.get(href);
              if (externalFile) {
                showStatus(`Found ${href} in folder`, 'info');
              } else {
                showStatus(`${href} not found in folder, prompting...`, 'info');
                externalFile = await selectFile(href);
              }
            } else {
              // No folder loaded, prompt for file
              externalFile = await selectFile(href);
            }

            if (!externalFile) {
              showStatus(`Skipped ${href} (no file selected)`, 'info');
              continue;
            }

            const externalSVGText = await externalFile.text();
            const externalDoc = parser.parseFromString(externalSVGText, 'image/svg+xml');
            const externalSVG = externalDoc.documentElement;

            // Create a group element to wrap the external SVG content
            const group = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'g');

            // Copy attributes from image element for positioning
            const x = parseFloat(img.getAttribute('x') || 0);
            const y = parseFloat(img.getAttribute('y') || 0);
            const width = img.getAttribute('width');
            const height = img.getAttribute('height');

            // Apply transform for positioning
            if (x !== 0 || y !== 0) {
              group.setAttribute('transform', `translate(${x}, ${y})`);
            }

            // Copy viewBox from external SVG if it exists
            const viewBox = externalSVG.getAttribute('viewBox');
            if (viewBox && width && height) {
              // Add viewBox info as comment
              const comment = svgDoc.createComment(` Inlined from ${href}, original viewBox: ${viewBox} `);
              group.appendChild(comment);
            }

            // Copy all child elements from external SVG
            const children = Array.from(externalSVG.children);
            children.forEach(child => {
              const imported = svgDoc.importNode(child, true);
              group.appendChild(imported);
            });

            // Replace image element with group
            img.parentNode.replaceChild(group, img);

          } catch (err) {
            showStatus(`Error loading ${href}: ${err.message}`, 'error');
            console.error(err);
          }
        }

        // Serialize the result
        const serializer = new XMLSerializer();
        processedSVG = serializer.serializeToString(svgElement);

        // Clean up XML declaration if needed
        if (!processedSVG.startsWith('<?xml')) {
          processedSVG = '<?xml version="1.0" encoding="UTF-8"?>\n' + processedSVG;
        }

        // Show preview
        previewDiv.innerHTML = processedSVG;
        sourceCode.value = processedSVG;

        showStatus('Success! SVG processed and ready to download.', 'success');
        downloadBtn.disabled = false;

      } catch (err) {
        showStatus('Error: ' + err.message, 'error');
        console.error(err);
      } finally {
        processBtn.disabled = false;
      }
    });

    downloadBtn.addEventListener('click', () => {
      if (!processedSVG) return;

      const blob = new Blob([processedSVG], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');

      const newFileName = originalFileName.replace('.svg', '-inlined.svg');
      a.href = url;
      a.download = newFileName;
      a.click();

      URL.revokeObjectURL(url);
      showStatus(`Downloaded: ${newFileName}`, 'success');
    });

    toggleSourceBtn.addEventListener('click', () => {
      if (sourceCode.style.display === 'none') {
        sourceCode.style.display = 'block';
        toggleSourceBtn.textContent = 'Hide Source';
      } else {
        sourceCode.style.display = 'none';
        toggleSourceBtn.textContent = 'Show Source';
      }
    });

    function showStatus(message, type) {
      statusDiv.textContent = message;
      statusDiv.className = 'status ' + type;
      statusDiv.style.display = 'block';
    }
  </script>
</body>
</html>
